Aravind Vadali 404272660
Jeffrey Jiang 904255069

Lab 1a:
Algorithm for creating command trees:
Maintain two stacks (one for operators, one for commands)
switch (COMMAND_TYPE):
  case SIMPLE_COMMAND:
    push SIMPLE_COMMAND onto commandStack
    
  case BINARY_OPERATOR:
    pop all operators off operatorStack until reached a lower-precedence operator or OPEN_PAREN
    for each operator
      pop two commands off commandStack
      combine two commands and operator into single command
      push combined command into operatorStack
  
  case OPEN_PAREN:
    push SUBSHELL_COMMAND onto operator stack
    
  case CLOSE_PAREN:
    pop all operators until OPEN_PAREN
    for each operator
      pop two commands off commandStack
      combine two commands and operator into single command
      push combined command into operatorStack
      
  case REDIRECT:
    if preceded by a command:
      add an input or output (for < or > respectively) to top of commandStack
  
  case WHITESPACE:
    advance to next character
  
  case #:
    advance character into next NEWLINE or EOF
  
  case NEWLINE:
    if preceded by a command:
      if only one in a row:
        acts as semicolon
      else if two in a row:
        end the command tree
    else if preceded by a semicolon:
      if there are two newlines in a row
        treat the semicolon as removed
      else:
        treat as WHITESPACE
    
  case EOF:
    pop all operators
    for each operator
      pop two commands off commandStack
      combine two commands and operator into single command
      push combined command into operatorStack
      
Meets spec description to the best of our knowledge.

Lab 1b: 
Make a new recursive function called execute() that takes a command as input. 
Breaks commands into their multiple types. 
switch (c->type): 
  case SIMPLE_COMMAND:
    check for input/output that must be dealt with. 
    check for exec as first word: 
      run command, using word array. 
  case AND_COMMAND:
    fork a process. 
    in child:   run the left command. 
    in parent:  check exit status of left command. 
      if successful, fork a new process. 
        check exit status of right command. 
        determine status of AND_COMMAND from right command. 
      else
        AND_COMMAND failed. 
        exit the process. 
  case OR_COMMAND: 
    fork a process. 
    in child:   run the left command. 
    in parent:  check exit status of left command. 
      if unsuccessful, fork a new process. 
        check exit status of right command. 
        determine status of OR_COMMAND from right command. 
      else
        OR_COMMAND succeeded. 
        exit the process. 
  case SEQUENCE_COMMAND:
    fork a process. 
    in child:   run the left command. 
    in parent:  
      fork a new process. 
        check exit status of right command. 
        determine status of SEQUENCE_COMMAND from right command. 
  case SUBSHELL_COMMAND:
    fork a new process. 
    in child:   check/setup redirections. 
      run inner command(s). 
    in parent: 
      check exit status of inner command. 
      copies exit status into own exit status. 
  case PIPE_COMMAND: 
    create a pipe. 
    fork a new process. 
    in child1: 
      setup the read end. 
      execute the right/reading command. 
    in parent1: 
      fork a new process. 
      in child2: 
        setup the write end. 
        execute the writing/left command. 
      in parent2: 
        close the pipe and wait for commands to finish. 
        set exit statuses of the two subcommands. 
        determine its own exit status. 
        
also made some minor changes to 1a to account for some bugs (which were, in general, nonconsequential)
